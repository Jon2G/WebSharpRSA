@page "/theory"
@inherits MathJaxContentComponent
@inject IJSRuntime _jsRuntime

<PageTitle>Teoría</PageTitle>



<div style="text-align: center">
    <h3>INSTITUTO POLITÉCNICO NACIONAL</h3>

    <h4>
        ESCUELA SUPERIOR DE INGENIERÍA MECANICA Y ELECTRICA
        <br />
        UNIDAD CULHUACAN
    </h4>

    <h5>MAESTRÍA EN INGENIERÍA EN SEGURIDAD Y TECNOLOGÍAS DE LA INFORMACIÓN</h5>
</div>

<div style="text-align: center; margin: 10px; padding: 10px;">
    <div style="border: solid black 2px" />
    <div style="border: solid black 1px; width: 70%; margin-left: 15%; margin-top: 5px;margin-bottom: 5px;" />
    <h4>IMPLEMENTACIÓN DEL ALGORITMO DE CIFRADO RSA</h4>
    <div style="border: solid black 1px; width: 70%; margin-left: 15%; margin-top: 5px;margin-bottom: 5px;" />
    <div style="border: solid black 2px" />
</div>

<div style="text-align: center; margin: 10px; padding: 10px;">
    <h5>Presenta:</h5>
    <h5>Jonathan Eduardo Garcíá García</h5>
    <a href="mailto:jgarciag1404@alumno.ipn.mx">jgarciag1404@alumno.ipn.mx</a>
</div>

<div style="margin: 10px; padding: 10px;">
    <h6>Profesor:</h6>
    <h6>Dr. Eduardo Vázquez Fernández</h6>
</div>


<button class="btn btn-primary" @onclick="ViewCode">Ver código en Github</button>

<div style="height: 100px"/>

<h5>El algoritmo de cifrado RSA</h5>
El algoritmo RSA es un algoritmo criptográfico asimétrico; esto significa que utiliza una clave pública y una clave privada (es decir, dos claves diferentes vinculadas matemáticamente). Como sugieren sus nombres, una clave pública se comparte públicamente, mientras que una clave privada es secreta y no debe compartirse con nadie.
<br />
<br />
El algoritmo RSA lleva el nombre de quienes lo inventaron en 1978: Ron Rivest, Adi Shamir y Leonard Adleman.
<br />
<br />
La siguiente ilustración destaca cómo funciona la criptografía asimétrica:
<img src="imgs/rsa.svg" style="max-width: 100%;height: auto;" />

<b><h5>Teorema de Euler</h5></b>

El teorema de Euler es la base del algoritmo RSA, y es importante entenderlo antes de explicar el algoritmo. <br/>
La idea es que si tenemos dos números a y n tal que son coprimos, entonces:
<Equation Value="a^{\phi(n)} \equiv 1 \;\; (\bmod n\;)" />
<br/>
<div style="height: 30px"/>
Donde 
<Equation Value="\phi{n}"/>
es conocida como la función 
<Equation Value="\phi"/>
de Euler, y para números primos, es: 
<Equation Value="\phi{p} = p - 1"/>
<br/>
Para un producto de dos números primos 
<Equation Value="pq"/>
entonces 
<Equation Value="\phi(pq) = \phi(p) \phi(q)"/>


<div style="height: 50px"/>
<b><h5> Generando las claves</h5></b>
<ol>
    <li>Seleccione dos números primos grandes x,y.<br/>
        Los números primos deben ser grandes para que a alguien le resulte difícil descifrar.
    </li>
    <div style="height: 10px"/>
    <li>Calcular <Equation Value="n=x*y"/></li>
    <div style="height: 10px"/>
    <li>Calcular la función Phi <Equation Value="\phi(n)=(x-1)(y-1)"/></li>
    <div style="height: 10px"/>
    <li>Seleccionar un número entero e, tal que e sea coprimo con <Equation Value="\phi(n)"/> y <Equation Value="1<e<\phi(n)" /><br/>El par de números (n,e) conforman la llave pública.</li>
    <div style="height: 10px"/>
    <MudCard Style="background-color: ghostwhite">
        <MudCardHeader Style="padding: 3px"><h6><b>Nota:</b></h6></MudCardHeader>
        <MudCardContent Style="padding: 3px">
            <p>Dos enteros son coprimos si solo un el único entero positivo los divide es 1</p>
        </MudCardContent>
    </MudCard>
    <div style="height: 10px"/>
    <li>Calcular d de tal forma que <Equation Value="e*d=1mod(\phi(n))"/> 
        <div style="height: 10px"/>
        El par de números n,d conforman la llave privada.
        <div style="height: 10px"/>
        <MudCard Style="background-color: ghostwhite">
            <MudCardContent Style="padding: 3px">
                <p>d puede ser encontrada utilizando el algoritmo extendido de Euclides</p>
            </MudCardContent>
        </MudCard>

        </li>
</ol>

<section style="text-align: center">
    <figure>
        <img style="margin: auto" src="imgs/eea_alg.jpg" />
        <figcaption>
            Algoritmo Extendido de Euclides
        </figcaption>
    </figure>
</section>

<div style="height: 50px"/>
<b><h5>Cifrado</h5></b>
Cada caracter del texto plano debe convertirse en su representación decimal.
<div style="height: 10px"/>
<table>
    <thead>
    <tr>
        <th>Texto</th>
        <th>A</th>
        <th>B</th>
        <th>C</th>
        <th>D</th>
        <th>E</th>
        <th>F</th>
        <th>G</th>
        <th>H</th>
        <th>I</th>
        <th>J</th>
        <th>K</th>
        <th>L</th>
        <th>M</th>
        <th>N</th>
        <th>O</th>
        <th>P</th>
        <th>Q</th>
        <th>R</th>
        <th>S</th>
        <th>T</th>
        <th>U</th>
        <th>V</th>
        <th>W</th>
        <th>X</th>
        <th>Y</th>
        <th>Z</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Valor</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
        <td>5</td>
        <td>6</td>
        <td>7</td>
        <td>8</td>
        <td>9</td>
        <td>10</td>
        <td>11</td>
        <td>12</td>
        <td>13</td>
        <td>14</td>
        <td>15</td>
        <td>16</td>
        <td>17</td>
        <td>18</td>
        <td>19</td>
        <td>20</td>
        <td>21</td>
        <td>22</td>
        <td>23</td>
        <td>24</td>
        <td>25</td>
        <td>26</td>
    </tr>
    </tbody>
</table>
<div style="height: 10px"/>
De modo que el texto completo es representado con el número: 
1234567891011121314151617181920212223242526
<div style="height: 10px"/>
<MudCard Style="background-color: ghostwhite">
    <MudCardContent Style="padding: 3px">
        <Equation Value="C=P^emod(n)"></Equation>
        <div style="height: 10px"/>
        <Equation Value="C={1234567891011121314151617181920212223242526}^emod(n)"></Equation>
    </MudCardContent>
</MudCard>

<div style="height: 10px"/>
Donde C representa al texto cifrado.
<div style="height: 20px"/>
<b><h5>Descifrado</h5></b>
Teniendo el número C que representa al texto cifrado hacemos:
<div style="height: 10px"/>
<MudCard Style="background-color: ghostwhite">
    <MudCardContent Style="padding: 3px">
        <Equation Value="P=C^dmod(n)"></Equation>
    </MudCardContent>
</MudCard>
<div style="height: 10px"/>
El resultado de P será el número que representa al texto original

<div style="height: 20px"/>
<h5>Implementación propuesta:</h5>
<pre class="line-numbers">
<code class="language-cs">
        @((MarkupString)@"double x = 3;
double y = 7;
  
double n = x*y;
  
double e = 2;
double phi = (x-1)*(y-1);
while (e < phi)
{
    if (gcd(e, phi)==1)
    break;
        else
    e++;
}
  
BigInteger k 
BigInteger limit = p * q;
for (BigInteger i = 1; i < limit; i += 2)
{
    if (i != p && i != q){
        if (i>1 && i < phi && phi % i != 0){
            k=i;
            break;
        }
    }
}

BigInteger d = (1 + (k*phi))/e;
  
BigInteger msg = 20;
  
// Cifrado
BigInteger c = BigInteger.Pow(msg, e);
c = BigInteger.Mod(c, n);
  
// Descifrado
BigInteger m =BigInteger.Pow(c, d);
m = BigInteger.Mod(m, n);
    
//Algoritmo extenido de euclides
int gcd(int a, int h)
{
    int temp;
    while (1)
    {
        temp = a%h;
        if (temp == 0)
          return h;
        a = h;
        h = temp;
    }
}");
  </code>
</pre>

<div style="height: 10vh" />

@code
{
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await _jsRuntime.InvokeVoidAsync("Prism.highlightAll");
    }
    public async Task ViewCode()
    {
        string url = "https://github.com/Jon2G/WebSharpRSA";
        await _jsRuntime.InvokeAsync<object>("open", url, "_blank");
    }
}
